#+TITLE:     Autotuning: A Design of Experiments Approach
#+AUTHOR:    \footnotesize Pedro Bruel \newline \scriptsize \emph{phrb@ime.usp.br}
#+EMAIL:     phrb@ime.usp.br
#+DATE:      \scriptsize \today
#+DESCRIPTION: 
#+KEYWORDS: 
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:t toc:t @:t \n:nil ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   tex:t latex:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 

#+STARTUP: beamer
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [10pt, compress, aspectratio=169, xcolor={table,usenames,dvipsnames}]
#+LATEX_HEADER: \mode<beamer>{\usetheme[numbering=fraction, progressbar=none, titleformat=smallcaps, sectionpage=none]{metropolis}}

#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)

#+LATEX_HEADER: \usepackage{sourcecodepro}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage[scale=2]{ccicons}
#+LATEX_HEADER: \usepackage{url}
#+LATEX_HEADER: \usepackage{relsize}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage{pgfplots}
#+LATEX_HEADER: \usepgfplotslibrary{dateplot}
#+LATEX_HEADER: \definecolor{Base}{HTML}{191F26}
#+LATEX_HEADER: \definecolor{Accent}{HTML}{157FFF}
#+LATEX_HEADER: \setbeamercolor{alerted text}{fg=Accent}
#+LATEX_HEADER: \setbeamercolor{frametitle}{bg=Base}
#+LATEX_HEADER: \setbeamercolor{normal text}{bg=black!2,fg=Base}
#+LATEX_HEADER: \setsansfont[BoldFont={Source Sans Pro Semibold},Numbers={OldStyle}]{Source Sans Pro}
#+LATEX_HEADER: \lstdefinelanguage{Julia}%
#+LATEX_HEADER:   {morekeywords={abstract,struct,break,case,catch,const,continue,do,else,elseif,%
#+LATEX_HEADER:       end,export,false,for,function,immutable,mutable,using,import,importall,if,in,%
#+LATEX_HEADER:       macro,module,quote,return,switch,true,try,catch,type,typealias,%
#+LATEX_HEADER:       while,<:,+,-,::,*,/},%
#+LATEX_HEADER:    sensitive=true,%
#+LATEX_HEADER:    alsoother={$},%
#+LATEX_HEADER:    morecomment=[l]\#,%
#+LATEX_HEADER:    morecomment=[n]{\#=}{=\#},%
#+LATEX_HEADER:    morestring=[s]{"}{"},%
#+LATEX_HEADER:    morestring=[m]{'}{'},%
#+LATEX_HEADER: }[keywords,comments,strings]%
#+LATEX_HEADER: \lstset{ %
#+LATEX_HEADER:   backgroundcolor={},
#+LATEX_HEADER:   basicstyle=\ttfamily\scriptsize,
#+LATEX_HEADER:   breakatwhitespace=true,
#+LATEX_HEADER:   breaklines=true,
#+LATEX_HEADER:   captionpos=n,
#+LATEX_HEADER:   commentstyle=\color{Accent},
#+LATEX_HEADER:   escapeinside={\%*}{*)},
#+LATEX_HEADER:   extendedchars=true,
#+LATEX_HEADER:   frame=n,
#+LATEX_HEADER:   keywordstyle=\color{Accent},
#+LATEX_HEADER:   language=R,
#+LATEX_HEADER:   rulecolor=\color{black},
#+LATEX_HEADER:   showspaces=false,
#+LATEX_HEADER:   showstringspaces=false,
#+LATEX_HEADER:   showtabs=false,
#+LATEX_HEADER:   stepnumber=2,
#+LATEX_HEADER:   stringstyle=\color{gray},
#+LATEX_HEADER:   tabsize=2,
#+LATEX_HEADER: }
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller\relax}
#+LATEX_HEADER: \graphicspath{{../img/}}
#+LATEX_HEADER: \addtobeamertemplate{block begin}{}{\justifying}

* Autotuning
** Autotuning: Optimizing Program Configurations
*** Architectures for High Performance Computing              :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:

    #+ATTR_LATEX: width=\columnwidth
    #+ATTR_ORG: :width 600
    [[../img/architectures.png]]

    How to write *efficient code* for each of these?

**** Autotuning                                                     :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

     #+LATEX: \vspace{.2cm}

     The process of *automatically finding* a *configuration* of a program that
     optimizes an *objective*

*** Configurations                                            :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_COL: 0.5
    :END:

    - Program Configuration
      - Algorithm, block size, $\dots$
    - Source code transformation
      - Loop unrolling, tiling, rotation $\dots$
    - Compiler configuration
      - =-O2=, vectorization, $\dots$
    - $\dots$
    
**** Objectives :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     
     - Execution time
     - Memory & power consumption
     - $\dots$

** Autotuning: Search Spaces    
*** Search Spaces                                            :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

     #+LATEX: \vspace{.2cm}
     
     Represent the *effect* of all possible
     *configurations* on the *objectives*

     Can be difficult to explore, with multiple *local optima*
     and *undefined regions*

*** Illustration                                                      :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    #+BEGIN_CENTER
    #+ATTR_LATEX: width=.8\columnwidth
    #+ATTR_ORG: :width 400
    [[../img/holder_table.pdf]]    

    *HÃ¶lder Table Function*
    #+END_CENTER
    
** Autotuning: Exploring Search Spaces
*** Issue 1: *Exponential Growth*                             :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

     #+LATEX: \vspace{.2cm}
     
     *Simple factors* can generate *large spaces*:

     - 30 *boolean* factors
     - $2^{30}$ combinations

**** Issue 2: *Geometry* :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - *Discrete* or *continous* factors
     - *``Smoothness''*
     - *Interactions* between factors

*** Issue 3: *Measurement Time*                               :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:

     #+LATEX: \vspace{.2cm}
     
     Time to *compile*:

     - *Benchmark* GPU applications: *1~10s*
     - *Benchmark* FPGA applications: *1~10min*
     - *Industrial* FPGA applications: *1~10h*
** Autotuning: Multiple Approaches
*** Popular Approaches                                        :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:
    #+LATEX: \footnotesize
    - \colorbox{red!25}{Exhaustive}
    - \colorbox{green!25}{Meta-Heuristics}
    - \colorbox{cyan!25}{Machine Learning}
    #+LATEX: \normalsize

    #+LATEX: \vspace{-.4cm}

    #+LATEX: \input{latex/popular_approaches.tex}

*** Main Issues                                               :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:
    - These approaches *assume*:
      - A *large number of function evaluations*
      - Seach space *``smoothness''*
      - Good solutions are *reachable*
    - After optimizing:
      - *Learn nothing* about the search space
      - *Can't explain* why optimizations work
* Applying Design of Experiments to Autotuning
** Applying Design of Experiments to Autotuning
*** Our Approach                                              :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

    #+LATEX: \vspace{.2cm}

    Using *efficient experimental design* to overcome issues
    related to *exponential growth*, *geometry*, and
    *measurement time*

**** Design Requirements                                            :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - Support a large number of factors (*Exponential Growth*)
     - Support numerical and categorical factors (*Geometry*)
     - Minimize function evaluations (*Measurement Time*)
   
*** Main Design Candidates                                    :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

    #+LATEX: \vspace{.2cm}

    *Screening* designs:

    - Estimate *main effects*
    - Aim to *minimize runs*
    - Assume *interactions are negligible*
    
    *Mixed-Level* designs:

    - Factors have *different numbers of levels*
    - Many *optimality criteria*

** Screening Designs
*** Plackett-Burman                                                   :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:

    #+LATEX: \vspace{.4cm}

    A Plackett-Burman *screening design* for $7$
    *2-level factors*:

    #+LATEX: \vspace{.2cm}

    #+LATEX: \input{latex/plackett_burman.tex}

*** Screening Designs                                         :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

    #+LATEX: \vspace{.2cm}

    *Plackett-Burman* designs for *2-level factors*:

    - *Orthogonal arrays* of *strength $2$*
    - Estimate the *main effects* of *$n$ factors with $n + 1$ runs*
    
    Construction:

    - For *$n + 1$ multiple of $4$*
    - Identical to a fractional design if *$n + 1$ is a power of two*

** Looking at Data: CUDA Compiler Flags
*** CUDA Compiler Flags                                       :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.3
    :BEAMER_env: block
    :END:
    - *Rodinia benchmark*
    - *15* factors, *few with multiple levels*
    - *$10^6$* combinations
    - *1~10s* to measure
    - *Screening experiment*:
      - *15 ``2-level''* factors
      - *4 ``dummy''* factors
*** Results                                                           :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.7
    :END:

    #+ATTR_LATEX: width=\columnwidth
    #+ATTR_ORG: :width 600
    [[../img/main_effects_gpu.png]]

** Mixed-Level Designs
*** Design Example                                                    :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:
    
    #+LATEX: \vspace{.1cm}

    A *multi-level* design for $1$ *2-level factor*
    and $3$ *3-level factors*:

    #+LATEX: \vspace{-.3cm}

    #+LATEX: \input{latex/multi_level.tex}

*** Mixed-Level Designs                                       :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:

**** Strategy 1: *Contractive Replacement*                          :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

     - Find *specific sets of \(k\)-level columns* of a design,
       *contract* the set into a new *factor of with more levels*
     - *Maintain orthogonality* of the design
     
**** Strategy 2: *Direct Construction*                              :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

     #+LATEX: \vspace{.2cm}

     Directly generate *small mixed-level designs* by
     solving *Mixed Integer Programming problems*

**** Strategy 3: *D-Optimal Designs*                                :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

** Looking at Data: FPGA Compiler Parameters
*** FPGA Compiler Parameters                                  :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.4
    :END:

    - *CHStone benchmark*
    - *141* factors, *most with multiple levels*
    - *\(10^{128}\)* combinations
    - *1~10min* to measure
    - *Multiple objectives*
    - *Search with meta-heuristics*:
      - *Unstructured data difficults analysis*
      - We are working on *obtaining more data*
*** Data                                                              :BMCOL:
    :PROPERTIES:
    :BEAMER_col: 0.6
    :END:

    #+ATTR_LATEX: width=\columnwidth
    #+ATTR_ORG: :width 600
    [[../img/fpga_space.png]]
* D-Optimal Designs
** D-Optimal Designs: Introduction
*** Linear Regression Model                                   :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:
    
    #+LATEX: \vspace{.2cm}

    A simple *regression model*:

    \(y = \beta_{0} + \beta_{1}x_{1} + \dots + \beta_{k}x_{k} + \epsilon\)

    We want to *estimate* \(\beta_{0,\dots,k}\):

    - Using \(n > k\) *observations* \(y_{1,\dots,n}\)
    - *Distinct* \(x_{i1,\dots,ik}, \; i = 1,\dots,n\)
    
    Gathering each *experiment*

    \(y_{i} = \beta_{0} + \beta_{1}x_{i1} + \dots + \beta_{k}x_{ik} + \epsilon_{i}\),

    we get:

    \(\mathbf{Y} = \bm{\beta}\mathbf{X} + \bm{\epsilon}\)
    
** D-Optimal Designs: Example
*** Example                                                   :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:
    - Factors & Levels: \(\mathbf{X} = \{x_1 = \{1, 2, 3\}, x_2 = \{1, 2, 3\}\}\)
    - Model: \(\mathbf{Y} = \mathbf{X}\beta + \eta\)
    - Minimize: *D-optimality*
    - Candidate set: *Full factorial*
    - Selection method: *Federov's algorithm*

**** Source code                                                    :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     #+HEADER: :results output :session *R* :exports code
     #+BEGIN_SRC R
     library(AlgDesign)
     full_factorial <- gen.factorial(c(3, 3),
                           factors = c(1, 2))
     output <- optFederov(~., full_factorial,
                          nTrials = 5)
     #+END_SRC

     #+RESULTS:

*** Output                                                    :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:
    
     #+LATEX: \scriptsize

     #+HEADER: :results output :session *R* :exports results
     #+BEGIN_SRC R
     output$design = t(output$design)
     output
     #+END_SRC

     #+RESULTS:
     #+begin_example
     [1] "Full Factorial Dimensions:"
     [1] 9 2
     $D
     [1] 0.2

     $A
     [1] 9

     $Ge
     [1] 0.333

     $Dea
     [1] 0.135

     $design
        1   2   4   7   9  
     X1 "1" "2" "1" "1" "3"
     X2 "1" "1" "2" "3" "3"

     $rows
     [1] 1 2 4 7 9
     #+end_example

     #+LATEX: \normalsize
* Perspectives
** Perspectives
*** Perspectives                                              :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:

**** *Short Term*                                                   :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - Study *small*, *balanced*, *orthogonal* and
       *multi-level* designs for *large numbers of factors*
     - Iteratively *drop least significant factors* with
       *user input*

**** *Long Term*                                                    :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - Use such designs to *autotune industrial-level FPGA applications*
     - Provide an *autotuning shared library* to applications

*** Takeaway                                                  :B_block:BMCOL:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_col: 0.5
    :END:

**** Target Scenario: *FPGA Compiler Parameters*                    :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     - *Large search space*
     - *Large measurement time*
     - Factors with *multiple levels*

     #+LATEX: \vspace{-.3cm}

**** Our Approach                                                   :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:

     #+LATEX: \vspace{.2cm}

     Using *efficient experimental designs* to overcome issues related
     to *exponential growth*, *geometry*, and *measurement time*

**** Main Design Candidates                                         :B_block:
     :PROPERTIES:
     :BEAMER_env: block
     :END:
     
     #+LATEX: \vspace{.2cm}

     *D-Optimal multi-level* designs

* Ending Title :B_ignoreheading:
  :PROPERTIES:
  :BEAMER_env: ignoreheading
  :END:
  #+LATEX: \maketitle
